diff --git chromium-69.0.3497.100/components/url_formatter/url_formatter.cc
index 37ff5e6..0897147 100644
--- chromium-69.0.3497.100/components/url_formatter/url_formatter.cc.orig
+++ chromium-69.0.3497.100/components/url_formatter/url_formatter.cc
@@ -406,19 +406,18 @@ bool IDNToUnicodeOneComponent(const base::char16* comp,
 
 }  // namespace
 
 const FormatUrlType kFormatUrlOmitNothing = 0;
 const FormatUrlType kFormatUrlOmitUsernamePassword = 1 << 0;
 const FormatUrlType kFormatUrlOmitHTTP = 1 << 1;
 const FormatUrlType kFormatUrlOmitTrailingSlashOnBareHostname = 1 << 2;
 const FormatUrlType kFormatUrlOmitHTTPS = 1 << 3;
 const FormatUrlType kFormatUrlExperimentalElideAfterHost = 1 << 4;
 const FormatUrlType kFormatUrlOmitTrivialSubdomains = 1 << 5;
 const FormatUrlType kFormatUrlTrimAfterHost = 1 << 6;
 
 const FormatUrlType kFormatUrlOmitDefaults =
-    kFormatUrlOmitUsernamePassword | kFormatUrlOmitHTTP |
-    kFormatUrlOmitTrailingSlashOnBareHostname;
+    kFormatUrlOmitNothing;
 
 base::string16 FormatUrl(const GURL& url,
                          FormatUrlTypes format_types,
                          net::UnescapeRule::Type unescape_rules,
@@ -490,8 +477,7 @@ base::string16 FormatUrlWithAdjustments(
   new_parsed->scheme = parsed.scheme;
 
   // Username & password.
-  if (((format_types & kFormatUrlOmitUsernamePassword) != 0) ||
-      ((format_types & kFormatUrlTrimAfterHost) != 0)) {
+  if (false) {
     // Remove the username and password fields. We don't want to display those
     // to the user since they can be used for attacks,
     // e.g. "http://google.com:search@evil.ru/"
@@ -532,8 +518,7 @@ base::string16 FormatUrlWithAdjustments(
     *prefix_end = static_cast<size_t>(url_string.length());
 
   // Host.
-  bool trim_trivial_subdomains =
-      (format_types & kFormatUrlOmitTrivialSubdomains) != 0;
+  bool trim_trivial_subdomains = false;
   AppendFormattedComponent(spec, parsed.host,
                            HostComponentTransform(trim_trivial_subdomains),
                            &url_string, &new_parsed->host, adjustments);
@@ -550,12 +535,10 @@ base::string16 FormatUrlWithAdjustments(
   }
 
   // Path & query.  Both get the same general unescape & convert treatment.
-  if ((format_types & kFormatUrlTrimAfterHost) ||
-      ((format_types & kFormatUrlExperimentalElideAfterHost) &&
-       url.IsStandard() && !url.SchemeIsFile() && !url.SchemeIsFileSystem())) {
+  if (false) {
     // Only elide when the eliding is required and when the host is followed by
     // more than just one forward slash.
-    bool should_elide = (format_types & kFormatUrlExperimentalElideAfterHost) &&
+    bool should_elide = false &&
                         ((parsed.path.len > 1) || parsed.query.is_valid() ||
                          parsed.ref.is_valid());
 
@@ -581,8 +564,7 @@ base::string16 FormatUrlWithAdjustments(
     adjustments->push_back(base::OffsetAdjuster::Adjustment(
         parsed.path.begin + new_path_len, trimmed_length, new_path_len));
 
-  } else if ((format_types & kFormatUrlOmitTrailingSlashOnBareHostname) &&
-             CanStripTrailingSlash(url)) {
+  } else if (false) {
     // Omit the path, which is a single trailing slash. There's no query or ref.
     if (parsed.path.len > 0) {
       adjustments->push_back(base::OffsetAdjuster::Adjustment(
@@ -614,12 +596,7 @@ base::string16 FormatUrlWithAdjustments(
   // the formatted URL is directly pre-filled into an input field.)  For this
   // reason we avoid stripping schemes in this case.
   const char kFTP[] = "ftp.";
-  bool strip_scheme =
-      !base::StartsWith(url.host(), kFTP, base::CompareCase::SENSITIVE) &&
-      (((format_types & kFormatUrlOmitHTTP) &&
-        url.SchemeIs(url::kHttpScheme)) ||
-       ((format_types & kFormatUrlOmitHTTPS) &&
-        url.SchemeIs(url::kHttpsScheme)));
+  bool strip_scheme = false;
 
   // If we need to strip out schemes do it after the fact.
   if (strip_scheme) {
